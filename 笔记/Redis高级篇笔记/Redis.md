# Redis数据类型

常见的有五种：**String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）**。 **BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）**。

## RedisObject

```c
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;
    void *ptr;
} robj;
```

结构体RedisObject定义了5个属性：type、enconding、lru、refcount和*prt

**type**：当前值对象的数据类型

**encoding**：当前值对象底层编码类型

**lru**：储存最后一次使用此对象的时间等信息

**refcount**：记录对象引用次数

***prt**：指向真正底层数据结构的指针

---

1、**type**属性

type主要存储当前value对象的数据类型，如下：

REDIS_STRING 字符串对象

REDIS_LIST 列表对象

REDIS_HAST 哈希对象

REDIS_SET 集合对象

REDIS_ZSET 有序集合对象

2、**encoding**属性

简单说encoding存储当前值对象底层编码的实现方式。不同type对象对应不同的编码，下表可以看出上述五种对象中每种对象至少对应了两种编码。

3、**lru**属性

lru记录此对象最后一次访问的时间。

当redis内存回收算法设置为volatile-lru或者allkeys-lru时候redis会优先释放最久没有被访问的数据。

4、**refcount**属性

用于共享计数，类似于jvm的引用计数垃圾回收算法，当refcount为0时，表示没有其它对象引用，可以进行释放此对象。

5、**ptr**指针属性

ptr 指针是指向对象的底层实现数据结构。

## String

**底层实现**：int 和 SDS（简单动态字符串）

SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：

- **SDS 不仅可以保存文本数据，还可以保存二进制数据**。因为 `SDS` 使用 `len` 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 `buf[]` 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。
- **SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 `len` 属性记录了字符串长度，所以复杂度为 `O(1)`。
- **Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出**。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。

**内部编码**有 3 种 ：**int、raw和 embstr**。

**int**

如果一个字符串对象保存的是整数值，并且这个整数值可以用`long`类型来表示，那么字符串对象会将整数值保存在字符串对象结构的`ptr`属性里面（将`void*`转换成 long），并将字符串对象的编码设置为`int`。

**embstr**

如果字符串对象保存的是一个字符串，并且这个字符申的长度小于等于 44字节（redis 5.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为`embstr`， `embstr`编码是专门用于保存短字符串的一种优化编码方式。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/embstr.png)

**raw**

如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 44字节（redis 5.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为`raw`。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/raw.png)

`embstr`和`raw`编码都会使用`SDS`来保存值

使用**embstr**的**优点**：

- `embstr`编码将创建字符串对象所需的内存分配次数从 `raw` 编码的两次降低为一次；
- 释放 `embstr`编码的字符串对象同样只需要调用一次内存释放函数；
- 因为`embstr`编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。

**缺点**：

- 如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以**embstr编码的字符串对象实际上是只读的**，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。

## List

**底层实现**：quicklist，实际还是双向链表和紧凑列表

quicklist内部存储结构:

quicklist中每一个节点都是一个quicklistNode对象，然后各个quicklistNode就构成了一个列表quicklist：



```c
typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        /* total count of all entries in all listpacks */
    unsigned long len;          /* number of quicklistNodes */
    signed int fill : QL_FILL_BITS;       /* fill factor for individual nodes */
    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */
    unsigned int bookmark_count: QL_BM_BITS;
    quicklistBookmark bookmarks[];
} quicklist;
```

```c
typedef struct quicklistNode {
    struct quicklistNode *prev;          /* 指向前一个节点的指针 */
    struct quicklistNode *next;          /* 指向下一个节点的指针 */
    unsigned char *entry;               /* 存储元素数据的指针 */
    size_t sz;                          /* entry的大小（以字节为单位） */
    unsigned int count : 16;            /* listpack中的元素数量（占16位） */
    unsigned int encoding : 2;          /* 元素编码方式（RAW==1或LZF==2） */
    unsigned int container : 2;         /* 元素容器类型（PLAIN==1或PACKED==2） */
    unsigned int recompress : 1;        /* 前一个节点是否被压缩过 */
    unsigned int attempted_compress : 1; /* 是否尝试压缩这个节点，但失败了（太小） */
    unsigned int dont_compress : 1;     /* 防止压缩将来要使用的entry */
    unsigned int extra : 9;             /* 用于未来用途的额外位 */
} quicklistNode;

```

大致原理

![原理](https://img-blog.csdnimg.cn/20210507113223880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1NDA2MDky,size_16,color_FFFFFF,t_70)

**控制ziplist元素长度**

quicklist结合了双向链表和ziplist的优点，但是同样也存在一个问题，一个quicklist包含多长的ziplist合适呢？需要找到一个平衡点：

- ziplist太短，内存碎片越多。
- ziplist太长，分配大块连续内存空间的难度就越大。

如何保持ziplist的合理长度，取决于具体的应用场景。

我们可以通过`list-max-ziplist-size`参数来控制ziplist的长度，基于2种原则，即元素的长度或元素大小的总和。

语法例如：

```java
list-max-ziplist-size -2  '默认值'
```

当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。

当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：

```java
-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb => 1024 bytes）
-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。
-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。
-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）
-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。
```

**compress属性**

list设计最容易被访问的是列表两端的数据，中间的访问频率很低，如果符合这个场景，list还有一个配置，可以对中间节点进行压缩（采用的LZF——一种无损压缩算法），进一步节省内存。配置如下：

```java
list-compress-depth 0 
```

compress属性表示压缩深度，这个参数表示一个quicklist两端不被压缩的节点个数。

可以通过参数list-compress-depth控制：

+ 0：不压缩(`默认值`)

- 1：首尾第1个元素不压缩
- 2：首位前2个元素不压缩
- 3：首尾前3个元素不压缩
- 以此类推

可用的场景例如：

1. **消息队列**：在消息队列中，新的消息通常会被添加到队列的尾部，而消费者会从队列的头部取出消息进行处理。这意味着队列的两端是最频繁访问的部分。
2. **缓存**：在缓存中，通常会使用LRU（最近最少使用）或LFU（最少使用）算法来管理缓存中的数据。这些算法通常会将最近使用的数据放在缓存的前面，而不常使用的数据可能会在列表的尾部。因此，缓存的头部通常包含热点数据。
3. **任务队列**：在任务队列中，新的任务通常会添加到队列的尾部，而工作者（消费者）会从队列的头部获取任务进行处理。
4. **历史记录**：在一些应用中，用户的历史操作记录通常会按照时间顺序存储在列表中，新的操作会添加到列表的尾部，而旧的操作可能会从列表的头部移除。

## Hash

Hash 是一个键值对（key - value）集合，其中 value 的形式如： `value=[{field1，value1}，...{fieldN，valueN}]`。Hash 特别适合用于存储对象。

**底层实现**：Hash 类型的底层数据结构是由**紧凑列表或哈希表**实现的：

- 如果哈希类型元素个数小于 `512` 个（默认值，可由 `hash-max-listpack-entries` 配置），所有值小于 `64` 字节（默认值，可由 `hash-max-listpack-value` 配置）的话，Redis 会使用**紧凑列表**作为 Hash 类型的底层数据结构；
- 如果哈希类型元素不满足上面条件，Redis 会使用**哈希表**作为 Hash 类型的 底层数据结构。

一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。

## Set

Set 类型是一个**无序**并**唯一**的**键值集合**，它的存储顺序不会按照插入的先后顺序进行存储。

一个集合最多可以存储 `2^32-1` 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取**交集**、**并集**、**差集**。

**底层实现**：Set 类型的底层数据结构是由**哈希表或整数集合**实现的：

- 如果集合中的元素都是整数且元素个数小于 `512` （默认值，`set-maxintset-entries`配置）个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构；
- 如果集合中的元素不满足上面条件，则 Redis 使用**哈希表**作为 Set 类型的底层数据结构。

**潜在的风险**：Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。

SRANDMEMBER set 3 随机返回集合中的元素（可重复）

SPOP  set 3随机返回集合中的元素（不可重复）

## zset

Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 **score**（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。

有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。

**底层结构**：压缩列表或跳表

- 如果有序集合的元素个数小于 `128` 个，并且每个元素的值小于 `64` 字节时，Redis 会使用**紧凑列表**作为 Zset 类型的底层数据结构；
- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；

# 持久化

Redis是内存数据库，宕机后数据会消失，Redis重启后快速恢复数据，要提供持久化机制。

两种持久化方式：**RDB**和**AOF**

Redis持久化不保证数据的完整性，有可能会丢数据。当Redis用作DB时，DB数据要完整，所以一定要有一个完整的数据源（文件、mysql），在系统启动时，从这个完整的数据源中将数据load到Redis中。

##  AOF 日志























### 跳表怎么实现和控制，时间复杂度和空间复杂度？

### redis hash是怎么实现的？

### 压缩列表和紧凑列表的区别，为什么要用紧凑列表替代压缩列表？















































# 分布式锁

SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：

- 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；
- 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。

一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：

```shell
SET lock_key unique_value NX PX 10000
```

- lock_key 就是 key 键；
- unique_value 是客户端生成的唯一的标识；
- NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；
- PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。

而解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。

可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。

```lua
// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁



# 分布式session？







#  缓存穿透

缓存穿透是指在使用缓存系统时，请求的数据在缓存中不存在，但却频繁地被请求，从而导致每次请求都需要查询数据库或其他数据存储系统，这会对系统的性能和资源造成不必要的压力。缓存穿透通常发生在以下情况：

1. 查询不存在的数据：如果恶意用户或者恶意请求频繁查询缓存中不存在的数据，缓存将无法命中，导致大量请求直接访问数据存储系统。
2. 高并发情况下：当有大量并发请求同时查询缓存中不存在的数据时，缓存系统可能无法应付这种负载，导致请求穿透缓存。

为了解决缓存穿透问题，可以采取以下一些方法：

1. 布隆过滤器（Bloom Filter）：使用布隆过滤器来检查请求的数据是否存在于缓存中，如果不存在，就不会继续查询数据库，从而减轻数据库压力。
2. 空值缓存：当查询结果为空时，也将这个结果缓存起来，但设置一个较短的过期时间，以防止恶意查询。这可以避免频繁查询不存在的数据。
3. 异常处理：在请求发现数据不存在时，可以生成一个异常或错误，并将其缓存起来，但要确保不会频繁生成相同异常，以减少缓存压力。
4. 限制频繁查询：实施限流或请求频率限制策略，以减少来自同一IP地址或用户的频繁查询。
5. 预热缓存：定期或在系统启动时，预先加载常用数据到缓存中，以减少冷启动时的缓存穿透问题。

# 缓存击穿

缓存击穿是指在使用缓存系统时，一个非常热门的数据突然失效或被删除，然后大量请求同时访问该数据，导致缓存无法命中，而不得不访问底层数据存储系统（通常是数据库），这会对系统的性能和资源造成严重的压力。缓存击穿通常发生在以下情况：

1. 数据热点：某些数据非常热门，被大量请求访问，而这些数据的缓存刚好在某一时刻失效。
2. 定时缓存失效：如果缓存数据采用定时过期策略，而且大量数据在同一时间失效，就会引发缓存击穿。

为了解决缓存击穿问题，可以采取以下一些方法：

1. 互斥锁：在缓存失效时，使用互斥锁来保护对底层数据存储系统的访问，以确保只有一个请求可以访问数据库，其他请求等待结果并重用。
2. 预加载热门数据：在缓存中定期或异步加载热门数据，以确保它们一直存在于缓存中，即使缓存失效，也能够立即提供服务。
3. 短暂的过期时间：将热门数据的缓存过期时间设置得较短，这可以减少击穿发生的可能性，同时允许数据定期刷新。
4. 延迟双刷：在某个请求发现缓存失效后，不是立刻去数据库查询数据，而是设置一个短暂的延迟，以等待其他请求将数据加载到缓存中。如果延迟后发现数据仍未缓存，再去查询数据库。
5. 使用分布式缓存锁：在分布式系统中，可以使用分布式锁来保护对底层数据的访问，以确保只有一个请求能够加载数据。

# 缓存雪崩

缓存雪崩是指在使用缓存系统时，大量缓存数据在同一时间失效，导致大量请求同时访问底层数据存储系统（通常是数据库），这会对系统的性能和资源造成严重的压力，甚至导致系统崩溃。缓存雪崩通常发生在以下情况：

1. 大规模的缓存数据同时失效：当大量缓存数据在同一时间段内过期或失效，可能由于缓存服务器重启、批量数据加载、错误的缓存过期设置等原因。
2. 缓存服务器故障：如果缓存服务器发生故障或宕机，大量请求将无法获取缓存数据，从而导致请求直接访问底层数据存储系统。

为了解决缓存雪崩问题，可以采取以下一些方法：

1. 随机化缓存过期时间：不要让大量缓存数据在同一时间过期，而是将过期时间随机分布，以降低数据同时失效的概率。
2. 分层缓存：使用多层缓存系统，将缓存数据分为热数据和冷数据，可以将热数据设置为永不过期，而冷数据设置较短的过期时间。
3. 数据预热：定期或异步加载缓存中的数据，以确保数据一直存在于缓存中，即使缓存失效。
4. 备用缓存：使用备用缓存或者多个独立的缓存服务器，以降低单点故障的风险。
5. 错开高峰期：尽量避免大规模的数据加载或缓存过期操作在高峰期同时发生，可以将它们错开以减少负载。
6. 数据异步加载：将缓存数据的加载操作异步化，避免阻塞主要请求流程。

